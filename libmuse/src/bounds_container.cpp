/**
 * \file      bounds_container.cpp
 * \brief     Provides the means of matching the pointer inside the bounding box generated by the client
 * \author    Lukáš Ručka <359687@mail.muni.cz>, Masaryk University, Brno, Czech Republic
 * \date      2012-03-18 16:55 UTC+1
 * \copyright BSD
 */

#define _BSD_SOURCE

#include <kerat/kerat.hpp>
#include <muse/bounds_container.hpp>
#include <cmath>
#include <cstring>
#include <string>
#include <sstream>
#include <iostream>
#include <cassert>
#include <iostream>
#include <unistd.h>
#include <sys/time.h>

namespace muse {
    namespace aggregators {

        bounds_container::bounds_container(const std::string & matching_regex, libkerat::slot_t container_slot, bool container_cascade)
            :m_slot(container_slot), m_cascade(container_cascade), m_was_ala(false)
        {
            memset(&m_regex, 0, sizeof(m_regex));

            int rslt = regcomp(&m_regex, matching_regex.c_str(), REG_EXTENDED | REG_NOSUB);
            if (rslt != 0){
                //! \todo throw
                const size_t REGEX_ERROR_BUFFSIZE = 2048;
                char * regex_error = new char[REGEX_ERROR_BUFFSIZE];
                memset(regex_error, 0, REGEX_ERROR_BUFFSIZE);
                regerror(rslt, &m_regex, regex_error, REGEX_ERROR_BUFFSIZE-1);
                std::cerr << "Regex: '" << matching_regex << "' is invalid due to :" << regex_error << std::endl;
                delete regex_error;
                regex_error = NULL;
                regfree(&m_regex);
            }
        }

        bounds_container::~bounds_container(){
            regfree(&m_regex);
        }

        libkerat::helpers::point_2d bounds_container::rotate_with_center(const libkerat::helpers::point_2d & point, const libkerat::helpers::point_2d & center, const libkerat::helpers::angle_2d & angle){

            using libkerat::helpers::point_2d;

            point_2d retval = point - center;

            // rotating the bounding box inner ellipse for the main axis to match x axis
            double tmp_cos = cos(-angle.get_angle());
            double tmp_sin = sin(-angle.get_angle());

            retval = point_2d(
                (tmp_cos * retval.get_x()) + (tmp_sin*retval.get_y()),
                ((-tmp_sin)*retval.get_x()) + (tmp_cos*retval.get_y())
            );

            retval += center;
            return retval;
        }

        bool bounds_container::inside_bound_ellipse(const libkerat::message::bounds & bound, const libkerat::helpers::point_2d & point){

            using libkerat::helpers::point_2d;
            point_2d rotated_point = rotate_with_center(point, bound, bound);

            double a = bound.get_width()/2;
            double b = bound.get_height()/2;

            // from now on, consider a to be the main axis
            assert(a >= b);

            double a_squared = (a * a);
            double b_squared = (b * b);

            double focus = sqrt(a_squared - b_squared);

            point_2d f1(bound.get_x() - focus, bound.get_y());
            point_2d f2(bound.get_x() + focus, bound.get_y());

            return ((libkerat::distance(f1, rotated_point) + libkerat::distance(f2, rotated_point)) < (2*a));
        }

        int bounds_container::process_container_frame(const libkerat::bundle_handle& to_process){
            //clear_bounds();

            // store bounds messages
            typedef libkerat::bundle_handle::const_iterator iterator;
            for (iterator i = to_process.begin(); i != to_process.end(); i++){
                libkerat::message::bounds * msg_bound = dynamic_cast<libkerat::message::bounds*>(*i);
                if (msg_bound != NULL){
                    libkerat::session_id_t sid = msg_bound->get_session_id();
                    bounds_map::iterator bnd = m_bounds.find(sid);

                    if (bnd != m_bounds.end()){
                        bnd->second = *msg_bound;
                    } else {
                        m_bounds.insert(bounds_map::value_type(sid, *msg_bound));
                    }

                    m_alives.insert(sid);
                } // alive message is processed by process_normal_frame
            }

            return 0;
        }

        int bounds_container::process_normal_frame(const libkerat::bundle_handle& to_process, libkerat::bundle_handle& output_frame){

            // make sure we won't have to deal with the self-asignment problem
            bm_handle_clear(output_frame);

            // process intermediate messages
            typedef libkerat::bundle_handle::const_iterator iterator;
            for (iterator i = to_process.begin(); i != to_process.end(); i++){

                libkerat::kerat_message * tmp = (*i)->clone();

                libkerat::helpers::point_2d * hp_point = dynamic_cast<libkerat::helpers::point_2d*>(tmp);
                libkerat::helpers::contact_session * hp_session = dynamic_cast<libkerat::helpers::contact_session*>(tmp);
                libkerat::message::bounds * msg_bounds = dynamic_cast<libkerat::message::bounds*>(tmp);

                libkerat::message::alive_associations * msg_ala = dynamic_cast<libkerat::message::alive_associations*>(tmp);
                libkerat::message::container_association * msg_coa = dynamic_cast<libkerat::message::container_association*>(tmp);

                libkerat::message::alive * msg_alive = dynamic_cast<libkerat::message::alive*>(tmp);

                if ((hp_point != NULL) && (hp_session != NULL) && (msg_bounds == NULL)){

                    libkerat::session_id_t sid = hp_session->get_session_id();
                    m_alives.insert(sid);
                    libkerat::component_id_t cid = 0;

                    cid_point_map & pt_map = m_points_buffer[sid];

                    libkerat::helpers::contact_component * hp_component = dynamic_cast<libkerat::helpers::contact_component*>(tmp);
                    if (hp_component != NULL){ cid = hp_component->get_component_id(); }

                    pt_map[cid] = *hp_point;

                    bm_handle_insert(output_frame, bm_handle_end(output_frame), tmp);
                    continue;
                } else if (msg_coa != NULL){
                    process_coa(*msg_coa, output_frame);
                } else if (msg_ala != NULL){
                    process_ala(*msg_ala);
                } else if (msg_alive != NULL){
                    process_alive(*msg_alive, output_frame);
                } else {
                    bm_handle_insert(output_frame, bm_handle_end(output_frame), tmp);
                    continue;
                }

                delete tmp;
                tmp = NULL;
            }

            return 0;
        }

        void bounds_container::process_coa(const libkerat::message::container_association& coa, libkerat::bundle_handle& output_frame){
            // we affect only coa messages with slot set to m_slot
            // there for, all other coa messages shall be passed through
            // m_slot messages are stored for further processing
            if (coa.get_slot() != m_slot){
                bm_handle_insert(output_frame, bm_handle_end(output_frame), coa.clone());
            } else {
                m_alives.insert(coa.get_session_id());
                m_containers[coa.get_session_id()] = coa;
            }
        }

        void bounds_container::process_ala(const libkerat::message::alive_associations& alive_assoc){
            // ala is always intercepted and waiting for alv
            m_ala_ids = alive_assoc.get_associations();
            // make sure that this message is send even if no associations were added
            m_was_ala = true;
        }

        void bounds_container::process_alive(const libkerat::message::alive& alive, libkerat::bundle_handle & output_frame){
            typedef libkerat::message::alive::alive_ids alive_ids;
            // cleanup
            alive_ids sids_to_remove = libkerat::extract_removed_ids(m_alives, alive.get_alives());
            libkerat::message::alive_associations::associated_ids alas = m_ala_ids;

            // delete removed session ids
            for (alive_ids::const_iterator i = sids_to_remove.begin(); i != sids_to_remove.end(); i++){
                m_points_buffer.erase(*i);
                m_bounds.erase(*i);
                m_containers.erase(*i);
                alas.erase(*i);
            }
            m_ala_ids = alas;

            sid_coa_map tmp_containers = m_containers;
            // commit all received points
            for (sid_cid_point_map::const_iterator cid_map = m_points_buffer.begin(); cid_map != m_points_buffer.end(); cid_map++){
                for (cid_point_map::const_iterator pt = cid_map->second.begin(); pt != cid_map->second.end(); pt++){
                    bool is_inside = false;
                    bool record_found = false;
                    // find previous association
                    if (!m_cascade){
                        for (sid_coa_map::iterator prev_bnd = tmp_containers.begin(); !(is_inside|record_found) && (tmp_containers.end() != prev_bnd); prev_bnd++){
                            libkerat::session_set coa_assoc = prev_bnd->second.get_associations();
                            if (coa_assoc.find(pt->first) != coa_assoc.end()){
                                record_found = true;
// commendted out due to experiment
//                                if (inside_bound_ellipse(m_bounds[prev_bnd->first], pt->second)){
//                                    is_inside = true;
//                                } else {
                                    coa_assoc.erase(pt->first);
                                    prev_bnd->second.set_associations(coa_assoc);
//                                }
                            }
                        }

                        if (is_inside){ continue; }
                    }

                    // find new association
                    for (bounds_map::const_iterator i = m_bounds.begin(); (!is_inside) && (i != m_bounds.end()); i++){
                        if (cid_map->first == i->first){ continue; }
                        is_inside = inside_bound_ellipse(i->second, pt->second);
                        if (is_inside){
                            libkerat::message::container_association & coa = tmp_containers[i->first];
                            libkerat::session_set coa_assoc = coa.get_associations();
                            coa_assoc.insert(cid_map->first);
                            coa.set_associations(coa_assoc);
                            coa.set_session_id(i->first);
                            coa.set_slot(m_slot);
                        }
                    }
                }
            }

            // add coa, construct ala
            libkerat::message::alive_associations::associated_ids ala_ids;
            for (sid_coa_map::iterator i = tmp_containers.begin(); i != tmp_containers.end(); i++){
                libkerat::message::container_association & assoc = i->second;;
                libkerat::message::container_association::associated_ids ids = assoc.get_associations();
                ala_ids.insert(ids.begin(), ids.end());
                bm_handle_insert(output_frame, bm_handle_end(output_frame), assoc.clone());
            }
            m_containers = tmp_containers;

            ala_ids.insert(m_ala_ids.begin(), m_ala_ids.end());
            libkerat::message::alive_associations tmpala(ala_ids);

            if ((!tmpala.get_associations().empty()) || (m_was_ala)){
                bm_handle_insert(output_frame, bm_handle_end(output_frame), tmpala.clone());
            }

            m_was_ala = !(tmpala.get_associations().empty());
            m_alives = alive.get_alives();
            bm_handle_insert(output_frame, bm_handle_end(output_frame), alive.clone());
        }

        int bounds_container::process_bundle(const libkerat::bundle_handle & to_process, libkerat::bundle_handle & output_frame){

            bool copy = false;
            const libkerat::bundle_handle * input = &to_process;
            if (&to_process == &output_frame){
                copy = true;
                input = bm_handle_clone(output_frame);
            }

            bool retval = 0;

            if (is_bundle_matching(*input)){
                retval = process_container_frame(*input);
                retval = process_normal_frame(*input, output_frame);
            } else {
                retval = process_normal_frame(*input, output_frame);
            }

            if (copy){ delete input; }

            return retval;
        }

        bool bounds_container::is_bundle_matching(const libkerat::bundle_handle& bundle){

            const libkerat::message::frame * msg_frame = bundle.get_frame();
            assert(msg_frame != NULL);
            if (msg_frame == NULL){ return false; }
            assert(msg_frame->is_extended());
            if (!msg_frame->is_extended()){ return false; }

            std::stringstream sx;
            sx << msg_frame->get_app_name() << ":" << libkerat::ipv4_to_str(msg_frame->get_address()) << "/" << msg_frame->get_instance();
            std::string tmp;
            std::getline(sx, tmp);
            return !regexec(&m_regex, tmp.c_str(), 0, NULL, 0);
        }

        void bounds_container::notify(const libkerat::client * cl){
            // do not forget to clean the previous stack!
            purge();

            libkerat::bundle_stack data = cl->get_stack();

            while (data.get_length() > 0){
                /**
                 * \todo make update reducible
                 */
                libkerat::bundle_handle current_frame = data.get_update();
                libkerat::bundle_handle * tmphx = new libkerat::bundle_handle;
                process_bundle(current_frame, *tmphx);

                if (tmphx->begin() == tmphx->end()){ delete tmphx; continue; }

                bm_stack_append(m_processed_frames, tmphx);
            }

            if (m_processed_frames.get_length()){ notify_listeners(); }
        }
        
        void bounds_container::purge(){ bm_stack_clear(m_processed_frames); }

        bool bounds_container::load(int count){
            return libkerat::adaptor::load(count);
        }

        bool bounds_container::load(int count, struct timespec timeout){
            return libkerat::adaptor::load(count, timeout);
        }

    }
}
