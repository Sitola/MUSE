/**
 * \file      apply.cpp
 * \brief     Provides the means of matching the pointer inside the bounding box generated by the client
 * \author    Lukáš Ručka <359687@mail.muni.cz>, Masaryk University, Brno, Czech Republic
 * \date      2012-03-18 16:55 UTC+1
 * \copyright BSD
 */

#define _BSD_SOURCE

#include <kerat/kerat.hpp>
#include <muse/apply.hpp>
#include <cmath>
#include <cstring>
#include <string>
#include <sstream>
#include <cassert>
#include <iostream>
#include <unistd.h>
#include <sys/time.h>

namespace muse {
    namespace aggregators {

        apply::apply(const std::string & matching_regex, const apply::adaptor_vector & adaptors_to_apply, bool free_adaptors)
            :m_free_adaptors(free_adaptors)
        {
            memset(&m_regex, 0, sizeof(m_regex));

            int rslt = regcomp(&m_regex, matching_regex.c_str(), REG_EXTENDED | REG_NOSUB);
            if (rslt != 0){
                //! \todo throw
                const size_t REGEX_ERROR_BUFFSIZE = 2048;
                char * regex_error = new char[REGEX_ERROR_BUFFSIZE];
                memset(regex_error, 0, REGEX_ERROR_BUFFSIZE);
                regerror(rslt, &m_regex, regex_error, REGEX_ERROR_BUFFSIZE-1);
                std::cerr << "Regex: '" << matching_regex << "' is invalid due to :" << regex_error << std::endl;
                delete regex_error;
                regex_error = NULL;
                regfree(&m_regex);
            }
            
            set_adaptors(adaptors_to_apply);
        }

        apply::~apply(){
            regfree(&m_regex);
            for (
                adaptor_vector::iterator adaptor_instance = m_adaptors.begin();
                adaptor_instance != m_adaptors.end();
                adaptor_instance++
            ){
                delete (*adaptor_instance);
                *adaptor_instance = NULL;
            }
            m_adaptors.clear();
        }
        
        void apply::set_adaptors(const apply::adaptor_vector & adaptors_to_apply){
            m_adaptors = adaptors_to_apply;
        }

        int apply::process_bundle(const libkerat::bundle_handle & to_process, libkerat::bundle_handle & output_frame){
            bool retval = 0;
            
            libkerat::bundle_handle tmp_1;
            libkerat::bundle_handle * current_output = &output_frame;
            const libkerat::bundle_handle * current_input = &to_process;
            
            if (is_bundle_matching(to_process)){
                
                for (
                    adaptor_vector::iterator adaptor_instance = m_adaptors.begin();
                    adaptor_instance != m_adaptors.end();
                    adaptor_instance++
                ){
                    int tmpr = (*adaptor_instance)->process_bundle(*current_input, *current_output);
                    if (retval == 0){ retval = tmpr; }
                    
                    current_output = (current_output == &tmp_1)?&output_frame:&tmp_1;
                    current_input = (current_input == &output_frame)?&tmp_1:&output_frame;
                }

                // ensure output frame is correct
                // if current_output is set to output_frame, then the previous
                // setting was the correct one!
                if (current_output == &output_frame){
                    output_frame = *current_input;
                }
            } else {
                output_frame = to_process;
            }

            return retval;
        }

        bool apply::is_bundle_matching(const libkerat::bundle_handle& bundle){

            const libkerat::message::frame * msg_frame = bundle.get_frame();
            assert(msg_frame != NULL);
            if (msg_frame == NULL){ return false; }
            assert(msg_frame->is_extended());
            if (!msg_frame->is_extended()){ return false; }

            std::stringstream sx;
            sx << msg_frame->get_app_name() << ":" << libkerat::ipv4_to_str(msg_frame->get_address()) << "/" << msg_frame->get_instance();
            std::string tmp;
            std::getline(sx, tmp);
            return !regexec(&m_regex, tmp.c_str(), 0, NULL, 0);
        }
        
        void apply::notify(const libkerat::client * cl){
            // do not forget to clean the previous stack!
            purge();

            libkerat::bundle_stack data = cl->get_stack();

            while (data.get_length() > 0){
                libkerat::bundle_handle current_frame = data.get_update();
                libkerat::bundle_handle * tmphx = new libkerat::bundle_handle;
                process_bundle(current_frame, *tmphx);

                // drop empty bundles
                if (tmphx->begin() == tmphx->end()){ delete tmphx; continue; }

                bm_stack_append(m_processed_frames, tmphx);
            }
			//breaks recognizers
            //if (m_processed_frames.get_length()){  notify_listeners(); }
            notify_listeners();
        }

        void apply::purge(){ bm_stack_clear(m_processed_frames); }
        
        bool apply::load(int count){
            return libkerat::adaptor::load(count);
        }

        bool apply::load(int count, struct timespec timeout){
            return libkerat::adaptor::load(count, timeout);
        }

    }
}
