/**
 * \file      filter.cpp
 * \brief     Provides the means of matching the pointer inside the bounding box generated by the client
 * \author    Lukáš Ručka <359687@mail.muni.cz>, Masaryk University, Brno, Czech Republic
 * \date      2012-03-18 16:55 UTC+1
 * \copyright BSD
 */

#define _BSD_SOURCE

#include <kerat/kerat.hpp>
#include <muse/filter.hpp>
#include <cmath>
#include <cstring>
#include <string>
#include <sstream>
#include <cassert>
#include <iostream>
#include <unistd.h>
#include <sys/time.h>

namespace muse {
    namespace aggregators {

        filter::filter(const std::string & matching_regex, libkerat::listener * sink)
            :m_sink(NULL)
        {
            memset(&m_regex, 0, sizeof(m_regex));

            int rslt = regcomp(&m_regex, matching_regex.c_str(), REG_EXTENDED | REG_NOSUB);
            if (rslt != 0){
                //! \todo throw
                const size_t REGEX_ERROR_BUFFSIZE = 2048;
                char * regex_error = new char[REGEX_ERROR_BUFFSIZE];
                memset(regex_error, 0, REGEX_ERROR_BUFFSIZE);
                regerror(rslt, &m_regex, regex_error, REGEX_ERROR_BUFFSIZE-1);
                std::cerr << "Regex: '" << matching_regex << "' is invalid due to :" << regex_error << std::endl;
                delete regex_error;
                regex_error = NULL;
                regfree(&m_regex);
            }
            
            set_sink(sink);
        }
        
        void filter::add_listener(libkerat::listener * lstnr){
            if (lstnr != m_sink){ libkerat::adaptor::add_listener(lstnr); }
        }
        
        void filter::del_listener(libkerat::listener * lstnr){
            if (lstnr != m_sink){ libkerat::adaptor::del_listener(lstnr); }
        }
        
        void filter::set_sink(libkerat::listener * sink){
            // remove possible sink from listeners
            if (sink != NULL){ libkerat::adaptor::del_listener(m_sink); }
            // disconnect current sink
            if (m_sink != NULL){ m_sink->notify_client_release(this); }
            
            // connect new sink
            m_sink = sink;
            if (m_sink != NULL){ m_sink->notify_client_bind(this); }
        }
        
        libkerat::bundle_stack filter::get_stack() const {
            if (m_tell_sink){
                return m_sinked_frames;
            } else {
                return m_filtered_frames;
            }
        }

        filter::~filter(){
            regfree(&m_regex);
        }

        int filter::process_bundle(const libkerat::bundle_handle & to_process, libkerat::bundle_handle & output_frame){
            libkerat::bundle_handle * newbundle = bm_handle_clone(to_process);

            if (is_bundle_matching(to_process)){
                bm_stack_append(m_filtered_frames, newbundle);
            } else {
                bm_stack_append(m_sinked_frames, newbundle);
            }

            output_frame = to_process;
            return 0;
        }

        bool filter::is_bundle_matching(const libkerat::bundle_handle& bundle){

            const libkerat::message::frame * msg_frame = bundle.get_frame();
            assert(msg_frame != NULL);
            if (msg_frame == NULL){ return false; }
            assert(msg_frame->is_extended());
            if (!msg_frame->is_extended()){ return false; }

            std::stringstream sx;
            sx << msg_frame->get_app_name() << ":" << libkerat::ipv4_to_str(msg_frame->get_address()) << "/" << msg_frame->get_instance();
            std::string tmp;
            std::getline(sx, tmp);
            return !regexec(&m_regex, tmp.c_str(), 0, NULL, 0);
        }
        
        void filter::purge(){
            bm_stack_clear(m_filtered_frames); 
            bm_stack_clear(m_sinked_frames); 
        }

        void filter::notify(const libkerat::client * cl){
            // do not forget to clean the previous stack!
            purge();

            libkerat::bundle_stack data = cl->get_stack();
            libkerat::bundle_handle tmp_bundle;

            while (data.get_length() > 0){
                libkerat::bundle_handle current_frame = data.get_update();
                process_bundle(current_frame, tmp_bundle);
            }

            m_tell_sink = false;
            if (m_filtered_frames.get_length()){ 
                notify_listeners(); 
            }
            if (m_sink != NULL) {
                m_tell_sink = true;
                m_sink->notify(this);
            }
        }

        bool filter::load(int count){
            return libkerat::adaptor::load(count);
        }

        bool filter::load(int count, struct timespec timeout){
            return libkerat::adaptor::load(count, timeout);
        }

    }
}
