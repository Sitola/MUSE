/**
 * \file      bounds_container.hpp
 * \brief     Provides the means of matching the pointer inside the bounding box generated by the client
 * \author    Lukáš Ručka <359687@mail.muni.cz>, Masaryk University, Brno, Czech Republic
 * \date      2012-03-18 16:55 UTC+1
 * \copyright BSD
 */

#ifndef MUSE_BOUNDS_CONTAINER_HPP
#define MUSE_BOUNDS_CONTAINER_HPP

#include <kerat/kerat.hpp>
#include <sys/types.h>
#include <regex.h>
#include <map>

namespace muse {
    namespace aggregators {

        class bounds_container: public libkerat::adaptor {
        public:

            bounds_container(const std::string & matching_regex = ".*", libkerat::slot_t container_slot = DEFAULT_SLOT, bool container_cascade = false);
            ~bounds_container();

            void notify(const libkerat::client * notifier);

            libkerat::bundle_stack get_stack() const { return m_processed_frames; }

            int process_bundle(const libkerat::bundle_handle & to_process, libkerat::bundle_handle & output_frame);

            void purge();

            virtual bool load(int count = 1);
            virtual bool load(int count, struct timespec timeout);

            static const libkerat::slot_t DEFAULT_SLOT = 65535;

        private:

            struct sid_cid_pair {
                libkerat::session_id_t   sid;
                libkerat::component_id_t cid;

                bool operator<(const sid_cid_pair & second) const { return (sid < second.sid) || ((sid == second.sid) && (cid < second.cid)); }
            };
            typedef std::map<libkerat::session_id_t, libkerat::message::bounds> bounds_map;
            typedef std::map<libkerat::component_id_t, libkerat::helpers::point_2d> cid_point_map;
            typedef std::map<libkerat::session_id_t, cid_point_map> sid_cid_point_map;
            typedef std::map<libkerat::session_id_t, libkerat::message::container_association> sid_coa_map;

            static libkerat::helpers::point_2d rotate_with_center(const libkerat::helpers::point_2d & point, const libkerat::helpers::point_2d & center, const libkerat::helpers::angle_2d & angle);

            static bool inside_bound_ellipse(const libkerat::message::bounds & bound, const libkerat::helpers::point_2d & point);
            bool is_bundle_matching(const libkerat::bundle_handle & bundle);

            int process_container_frame(const libkerat::bundle_handle & to_process);
            int process_normal_frame(const libkerat::bundle_handle & to_process, libkerat::bundle_handle & output_frame);

            inline void clear_bounds(){ m_bounds.clear(); }

            void process_alive(const libkerat::message::alive & alive, libkerat::bundle_handle & output_frame);
            void process_ala(const libkerat::message::alive_associations & alive_assoc);
            void process_coa(const libkerat::message::container_association & coa, libkerat::bundle_handle & output_frame);

            regex_t m_regex;
            libkerat::slot_t m_slot;
            bool m_cascade;

            sid_coa_map m_containers;
            bounds_map m_bounds;
            sid_cid_point_map m_points_buffer;
            libkerat::session_set m_ala_ids;
            libkerat::session_set m_alives;
            bool m_was_ala;

            libkerat::bundle_stack m_processed_frames;

        };
    }
}


#endif // MUSE_BOUNDS_CONTAINER_HPP
